<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Hammond-style Organ — v8 (mellower Leslie, numbered drawbars, on-screen sustain)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { --bg:#0b0e11; --panel:#12171d; --accent:#3aa675; --text:#e8eef5; --muted:#9db0c3; --slot:#0e151b; }
  html,body{height:100%}
  body{ margin:0; background:linear-gradient(180deg,#0b0e11,#0e1319); color:var(--text);
        font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial; display:flex; flex-direction:column; align-items:center; }
  header{padding:16px 20px; text-align:center; position:relative}
  header h1{margin:0; font-size:20px; letter-spacing:.6px}
  header p{margin:6px 0 0; color:#9db0c3; font-size:13px}
  .badge{position:absolute; right:16px; top:16px; font-size:12px; background:#1b2430; color:#a8f0cd; padding:4px 8px; border-radius:8px; border:1px solid #243340}

  #topbar{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:center; padding:10px 12px;
           background:var(--panel); border:1px solid #1f2832; border-radius:10px; margin:10px; }
  button, select, input[type=range]{ background:#18212a; color:var(--text); border:1px solid #25303a; border-radius:8px; padding:8px 10px; font-size:14px; }
  button:hover{background:#1d2833}
  button.primary{background:var(--accent); border-color:#2b7e59; color:#08130e; font-weight:600}
  .panel{ background:var(--panel); border:1px solid #1f2832; border-radius:12px; padding:14px; margin:10px; width:min(1100px,96%); }
  .flex{display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start}
  .section-title{font-weight:700; font-size:14px; margin-bottom:8px; letter-spacing:.5px; color:#cfe2f3}

  /* Drawbars with colored caps + scale markers */
  #drawbars{display:flex; gap:14px; align-items:flex-end; justify-content:center; flex-wrap:wrap}
  .db{ width:62px; display:flex; flex-direction:column; align-items:center; gap:8px; background:#0f151b;
       padding:10px 8px; border-radius:10px; border:1px solid #1b2430; }
  .db label{font-size:11px; color:#cfe2f3; text-align:center; min-height:2.2em}
  .slot{ width:48px; height:230px; border-radius:12px; background:var(--slot); border:1px solid #24303a;
         position:relative; overflow:hidden }
  .ticks{ position:absolute; left:4px; top:8px; bottom:8px; width:12px;
          display:flex; flex-direction:column; justify-content:space-between; align-items:center; pointer-events:none; }
  .ticks span{ font-size:9px; color:#6e8499; line-height:1; }
  .vslider{ -webkit-appearance:none; appearance:none; position:absolute; top:50%; left:50%;
            width:230px; height:40px; transform:translate(-50%,-50%) rotate(-90deg); }
  .vslider::-webkit-slider-runnable-track{ height:8px; background:#0b141a; border-radius:8px; border:1px solid #23313d; }
  .vslider::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:20px; height:20px; border-radius:6px;
                                  background:#3aa675; border:1px solid #2b7e59; margin-top:-6px; }
  .vslider::-moz-range-track{ height:8px; background:#0b141a; border-radius:8px; border:1px solid #23313d; }
  .vslider::-moz-range-thumb{ width:20px; height:20px; border-radius:6px; background:#3aa675; border:1px solid #2b7e59; }
  .cap{ position:absolute; top:6px; left:50%; transform:translateX(-50%); width:42px; height:24px;
        border-radius:6px; display:grid; place-items:center; font-weight:800; font-size:12px; border:1px solid #1b2430; }
  .cap.white{ background:#e9eef4; color:#101418; border-color:#cdd7e3; }
  .cap.black{ background:#0b0e12; color:#e8eef5; border-color:#212a34; }
  .cap.brown{ background:#7b4a1f; color:#f4e9da; border-color:#5f3917; }

  /* On-screen keyboard */
  .piano-top { display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; }
  .piano-wrap { padding:12px; background:#0f151b; border:1px solid #1b2430; border-radius:10px; overflow:hidden }
  .piano { position:relative; user-select:none; height:180px; display:block; margin:auto; }
  .key { box-sizing:border-box; cursor:pointer; }
  .key.white { position:relative; display:inline-block; width:32px; height:180px;
               background:linear-gradient(#18212a,#10171d); border:1px solid #1b2430; border-radius:0 0 6px 6px; }
  .key.white.active { background:linear-gradient(#2a7e59,#1f5d44); }
  .key.black { position:absolute; width:20px; height:112px; top:0;
               background:linear-gradient(#0a0e12,#0a0e12 60%,#091016); border:1px solid #1b2430;
               border-radius:0 0 6px 6px; z-index:5; box-shadow:0 2px 6px rgba(0,0,0,0.5); }
  .key.black.active { background:linear-gradient(#2a7e59,#1f5d44); }
  .piano-label{ color:#9db0c3; font-size:12px; margin-top:6px; text-align:center }

  #log{white-space:pre-wrap; font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-size:12px;
       color:#b5c9da; background:#0c1116; border:1px solid #1b2530; border-radius:8px; padding:10px; max-height:140px; overflow:auto}
</style>
</head>
<body>
<header>
  <h1>Hammond-style Organ</h1>
  <p>Vertical drawbars (colored caps + 1–8 scale) • mellower Leslie • key click • percussion • V/C • MIDI + on-screen keyboard</p>
  <div class="badge">v8</div>
</header>

<div id="topbar">
  <button id="startBtn" class="primary" title="Browsers require a click to start audio. Click this once, then play.">Start Audio</button>
  <div class="group">
    <label>MIDI In</label>
    <select id="midiIn"></select>
  </div>
  <div class="group">
    <span>Leslie:</span>
    <button data-leslie="stop">Stop</button>
    <button data-leslie="chorale">Chorale</button>
    <button data-leslie="tremolo">Tremolo</button>
    <button data-leslie="brake">Brake</button>
  </div>
</div>

<div class="panel">
  <div class="section-title">Drawbars</div>
  <div id="drawbars"></div>

  <div class="section-title" style="margin-top:12px">Vibrato/Chorus & Performance</div>
  <div class="flex">
    <div>
      <label for="vibMode">V/C Mode</label>
      <select id="vibMode">
        <option value="off">Off</option><option value="v1">V1</option><option value="v2">V2</option>
        <option value="v3" selected>V3</option><option value="c1">C1</option><option value="c2">C2</option><option value="c3">C3</option>
      </select>
    </div>
    <div>
      <label>Expression (CC11)</label>
      <input id="expr" type="range" min="0" max="1" step="0.001" value="0.2">
    </div>
    <div>
      <label>Overdrive</label>
      <input id="drive" type="range" min="0" max="1" step="0.001" value="0.15">
    </div>
    <div>
      <label>Key Click</label>
      <input id="click" type="range" min="0" max="1" step="0.001" value="0.35">
    </div>
    <div>
      <label>Percussion</label>
      <label><input type="checkbox" id="percOn" checked> On</label>
      <select id="percHarm"><option value="2">2nd</option><option value="3" selected>3rd</option></select>
      <select id="percDecay"><option value="fast" selected>Fast</option><option value="slow">Slow</option></select>
      <select id="percVol"><option value="normal" selected>Normal</option><option value="soft">Soft</option></select>
    </div>
  </div>
</div>

<div class="panel">
  <div class="section-title">On-screen Keyboard</div>
  <div class="piano-wrap">
    <div class="piano-top">
      <div class="piano-label">Click/tap keys to play (C3–C5).</div>
      <button id="sustainBtn" aria-pressed="false" title="Hold released on-screen keys until toggled off">Sustain: OFF</button>
    </div>
    <div id="piano" class="piano" aria-label="On-screen keyboard"></div>
  </div>
</div>

<div class="panel">
  <div class="section-title">MIDI + Log</div>
  <div class="minor">Notes on any channel. CC20–28 drawbars, CC11 expression, CC64 = Leslie slow/fast, CC1 = V/C mode.</div>
  <div id="log" style="margin-top:10px"></div>
</div>

<script>
/* ===== Utilities ===== */
const log = (...a)=>{ const el=document.getElementById('log'); el.textContent += a.join(' ') + "\n"; el.scrollTop = el.scrollHeight; };
const midiToFreq = n => 440 * Math.pow(2, (n - 69) / 12);

/* Drawbar labels + color caps (Hammond B-3 style) */
const DB_LABELS = ["16'","5⅓'","8'","4'","2⅔'","2'","1⅗'","1⅓'","1'"];
const DB_RATIOS = [0.5,1.5,1,2,3,4,5,6,8];
const DB_CAP = ["brown","brown","white","white","black","white","black","black","white"]; // cap colors
let drawbarNotches = [8,8,8,0,0,0,0,0,0]; // 0..8

/* ===== Audio graph ===== */
let ctx, master, organBus, preDrive, drive, vibLFO, vibGainCents,
    chorusDelayA, chorusDelayB, chorusLFOA, chorusLFOB, chorusMixA, chorusMixB,
    hornLFO, drumLFO, hornPan, drumPan, hornDelay, drumDelay, hornAM, drumAM,
    splitLP, splitHP;

let started = false, heldCount = 0;
const activeNotes = new Map();

function makeDriveCurve(amount,n=2048){ const k=amount*3+0.0001; const c=new Float32Array(n);
  for(let i=0;i<n;i++){ const x=(i/(n-1))*2-1; c[i]=Math.atan(k*x)/Math.atan(k);} return c; }

function setupAudio(){
  if(started) return;
  ctx=new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});

  master=ctx.createGain(); master.gain.value=0.9;
  const comp=ctx.createDynamicsCompressor();
  comp.threshold.value=-10; comp.knee.value=8; comp.ratio.value=2; comp.attack.value=0.003; comp.release.value=0.2;
  master.connect(comp).connect(ctx.destination);

  organBus=ctx.createGain();
  preDrive=ctx.createGain(); preDrive.gain.value=1;
  drive=ctx.createWaveShaper(); drive.curve=makeDriveCurve(parseFloat(document.getElementById('drive').value)); drive.oversample='4x';
  organBus.connect(preDrive).connect(drive);

  /* split horn/drum bands */
  splitLP=ctx.createBiquadFilter(); splitLP.type='lowpass'; splitLP.frequency.value=800;
  splitHP=ctx.createBiquadFilter(); splitHP.type='highpass'; splitHP.frequency.value=800;
  const tee=ctx.createGain(); drive.connect(tee); tee.connect(splitLP); tee.connect(splitHP);

  /* Leslie-ish modulation (mellow Doppler) */
  drumDelay=ctx.createDelay(0.02); drumDelay.delayTime.value=0.001;
  hornDelay=ctx.createDelay(0.02); hornDelay.delayTime.value=0.001;
  drumAM=ctx.createGain(); hornAM=ctx.createGain(); drumAM.gain.value=1; hornAM.gain.value=1;
  drumPan=ctx.createStereoPanner(); hornPan=ctx.createStereoPanner();

  splitLP.connect(drumDelay).connect(drumAM).connect(drumPan).connect(master);
  splitHP.connect(hornDelay).connect(hornAM).connect(hornPan).connect(master);

  hornLFO=ctx.createOscillator(); hornLFO.frequency.value=0.8; // chorale default
  drumLFO=ctx.createOscillator(); drumLFO.frequency.value=0.6;
  const lfoScaleHorn=ctx.createGain(); lfoScaleHorn.gain.value=1;
  const lfoScaleDrum=ctx.createGain(); lfoScaleDrum.gain.value=1;
  hornLFO.connect(lfoScaleHorn); drumLFO.connect(lfoScaleDrum);
  lfoScaleHorn.connect(hornPan.pan); lfoScaleDrum.connect(drumPan.pan);

  /* Doppler depth (mellow) */
  const hornDelayScale=ctx.createGain(); hornDelayScale.gain.value=0.0004; // v7/v8 mellow
  const drumDelayScale=ctx.createGain(); drumDelayScale.gain.value=0.00025;
  lfoScaleHorn.connect(hornDelayScale).connect(hornDelay.delayTime);
  lfoScaleDrum.connect(drumDelayScale).connect(drumDelay.delayTime);

  const hornBase=ctx.createConstantSource(); hornBase.offset.value=0.85; hornBase.start();
  const drumBase=ctx.createConstantSource(); drumBase.offset.value=0.95; drumBase.start();
  const hornDepth=ctx.createGain(); hornDepth.gain.value=0.22;
  const drumDepth=ctx.createGain(); drumDepth.gain.value=0.12;
  lfoScaleHorn.connect(hornDepth).connect(hornAM.gain);
  lfoScaleDrum.connect(drumDepth).connect(drumAM.gain);
  hornBase.connect(hornAM.gain); drumBase.connect(drumAM.gain);

  hornLFO.start(); drumLFO.start();

  /* vibrato/chorus */
  vibLFO=ctx.createOscillator(); vibLFO.type='sine'; vibLFO.frequency.value=6; vibLFO.start();
  vibGainCents=ctx.createGain(); vibGainCents.gain.value=12; vibLFO.connect(vibGainCents);

  chorusDelayA=ctx.createDelay(0.03); chorusDelayB=ctx.createDelay(0.03);
  chorusDelayA.delayTime.value=0.015; chorusDelayB.delayTime.value=0.02;
  chorusLFOA=ctx.createOscillator(); chorusLFOB=ctx.createOscillator();
  chorusLFOA.frequency.value=0.8; chorusLFOB.frequency.value=0.9;
  const cScaleA=ctx.createGain(); cScaleA.gain.value=0.004;
  const cScaleB=ctx.createGain(); cScaleB.gain.value=0.004;
  chorusLFOA.connect(cScaleA).connect(chorusDelayA.delayTime);
  chorusLFOB.connect(cScaleB).connect(chorusDelayB.delayTime);
  chorusLFOA.start(); chorusLFOB.start();
  chorusMixA=ctx.createGain(); chorusMixB=ctx.createGain(); chorusMixA.gain.value=0; chorusMixB.gain.value=0;
  drive.connect(chorusDelayA).connect(chorusMixA).connect(master);
  drive.connect(chorusDelayB).connect(chorusMixB).connect(master);

  started = true;
}

/* real-time params */
function setDrive(a){ if(drive) drive.curve=makeDriveCurve(a); }
function setVibratoMode(mode){
  let det=0, chor=0;
  switch(mode){
    case 'v1': det=5; break; case 'v2': det=10; break; case 'v3': det=15; break;
    case 'c1': det=4; chor=0.08; break; case 'c2': det=7; chor=0.12; break; case 'c3': det=10; chor=0.18; break;
    default: det=0; chor=0;
  }
  if(vibGainCents){ vibGainCents.gain.setTargetAtTime(det, ctx.currentTime, 0.05); }
  if(chorusMixA){ chorusMixA.gain.setTargetAtTime(chor, ctx.currentTime, 0.1); chorusMixB.gain.setTargetAtTime(chor, ctx.currentTime, 0.1); }
}
function setLeslie(mode){
  if(!ctx) return;
  const now=ctx.currentTime;
  const setF=(osc, f, tau)=>osc.frequency.setTargetAtTime(f, now, tau);
  if(mode==='stop'){ setF(hornLFO,0.01,0.8); setF(drumLFO,0.01,2.0); }
  else if(mode==='chorale'){ setF(hornLFO,0.8,0.8); setF(drumLFO,0.6,2.0); }
  else if(mode==='tremolo'){ setF(hornLFO,6.5,0.8); setF(drumLFO,4.5,2.0); }
  else if(mode==='brake'){ setF(hornLFO,0.0001,0.3); setF(drumLFO,0.0001,0.6); }
}

/* ===== Synth voice ===== */
function startNote(note, velocity=100){
  if(!started) return;
  if(activeNotes.has(note)) return;
  const freq=midiToFreq(note);

  const gate=ctx.createGain();
  gate.gain.setValueAtTime(0, ctx.currentTime);
  gate.gain.linearRampToValueAtTime(1, ctx.currentTime+0.004);

  /* 9-harmonic tonewheel stack */
  const oscs=[], vibLinks=[];
  for(let i=0;i<9;i++){
    const o=ctx.createOscillator(); o.type='sine'; o.frequency.value=freq*DB_RATIOS[i];
    const link=vibGainCents.connect(o.detune); vibLinks.push(link);
    const g=ctx.createGain(); g.gain.value=drawbarNotches[i]/8;
    o.connect(g).connect(gate); o.start();
    oscs.push({osc:o,gain:g});
  }

  /* Key click (short noise burst) */
  const clickLevel=parseFloat(document.getElementById('click').value);
  if(clickLevel>0.0001){
    const click=ctx.createBufferSource();
    const dur=0.012;
    const buf=ctx.createBuffer(1, Math.floor(ctx.sampleRate*dur), ctx.sampleRate);
    const ch=buf.getChannelData(0);
    for(let i=0;i<ch.length;i++){ ch[i]=(Math.random()*2-1)*Math.exp(-i/(ctx.sampleRate*0.002)); }
    click.buffer=buf;
    const cg=ctx.createGain(); cg.gain.value = clickLevel * 0.8;
    click.connect(cg).connect(gate);
    click.start();
  }

  /* Percussion (single-trigger) */
  const percOn=document.getElementById('percOn').checked;
  if(percOn && heldCount===0){
    const which=document.getElementById('percHarm').value;
    const fast=document.getElementById('percDecay').value==='fast';
    const soft=document.getElementById('percVol').value==='soft';
    const p=ctx.createOscillator(); p.type='sine';
    const ratio=(which==='2')?2.0:3.0; p.frequency.value=freq*ratio;
    const pg=ctx.createGain(); pg.gain.setValueAtTime(soft?0.22:0.38, ctx.currentTime);
    pg.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+(fast?0.22:0.65));
    p.connect(pg).connect(gate); p.start(); p.stop(ctx.currentTime+1);
  }

  const expr=parseFloat(document.getElementById('expr').value);
  const exprG=ctx.createGain(); exprG.gain.value=expr;
  gate.connect(exprG).connect(organBus);

  activeNotes.set(note,{gate,oscs,vibLinks});
  heldCount++;
}
function stopNote(note){
  if(!activeNotes.has(note)||!started) return;
  const d=activeNotes.get(note);
  const now=ctx.currentTime;
  d.gate.gain.cancelScheduledValues(now);
  d.gate.gain.setTargetAtTime(0.0001, now, 0.02);
  const stopAt=now+0.12;
  d.oscs.forEach(o=>o.osc.stop(stopAt));
  setTimeout(()=>{ try{ d.vibLinks.forEach(l=>l.disconnect&&l.disconnect()); }catch{} },200);
  activeNotes.delete(note);
  heldCount=Math.max(0, heldCount-1);
}

/* ===== Build vertical drawbars ===== */
const drawbarsEl=document.getElementById('drawbars');
function buildDrawbars(){
  drawbarsEl.innerHTML='';
  DB_LABELS.forEach((lab,i)=>{
    const wrap=document.createElement('div'); wrap.className='db';
    const lbl=document.createElement('label'); lbl.textContent=lab; wrap.appendChild(lbl);

    const slot=document.createElement('div'); slot.className='slot';

    /* scale 8..1 labels */
    const ticks=document.createElement('div'); ticks.className='ticks';
    for(let n=8;n>=1;n--){ const sp=document.createElement('span'); sp.textContent=n; ticks.appendChild(sp); }
    slot.appendChild(ticks);

    const cap=document.createElement('div'); cap.className='cap ' + DB_CAP[i];
    cap.textContent = drawbarNotches[i]; // live 0..8
    slot.appendChild(cap);

    const s=document.createElement('input'); s.className='vslider'; s.type='range'; s.min=0; s.max=8; s.step=1;
    s.value = 8 - drawbarNotches[i]; // invert so pull UP => louder
    s.addEventListener('input',()=>{
      const ui = parseInt(s.value,10);
      const notch = 8 - ui;
      drawbarNotches[i] = notch;
      cap.textContent = notch;
      if(ctx){ activeNotes.forEach(n=> n.oscs[i].gain.gain.setTargetAtTime(notch/8, ctx.currentTime, 0.01)); }
    });

    slot.appendChild(s);
    wrap.appendChild(slot);

    drawbarsEl.appendChild(wrap);
  });
}
buildDrawbars();

/* ===== UI hooks ===== */
document.getElementById('startBtn').addEventListener('click', async()=>{
  setupAudio(); await ctx.resume();
  setDrive(parseFloat(document.getElementById('drive').value));
  setVibratoMode(document.getElementById('vibMode').value);
  setLeslie('chorale'); // default slow
  log('Audio started. (v8)');
});
document.getElementById('drive').addEventListener('input', e=>{ if(!started) return; setDrive(parseFloat(e.target.value)); });
document.getElementById('expr').addEventListener('input', e=>{ if(!started) return; const v=parseFloat(e.target.value); activeNotes.forEach(n=> n.gate.gain.setTargetAtTime(v, ctx.currentTime, 0.03)); });
document.getElementById('vibMode').addEventListener('change', e=>{ if(!started) return; setVibratoMode(e.target.value); });
Array.from(document.querySelectorAll('[data-leslie]')).forEach(btn=> btn.addEventListener('click', ()=>{ if(!started) return; setLeslie(btn.getAttribute('data-leslie')); }));

/* ===== MIDI (unchanged: CC64 is used for Leslie, not sustain) ===== */
let midi, midiInSel=document.getElementById('midiIn'), currentInput;
function handleMIDIMessage(e){
  const [st,d1,d2]=e.data; const type=st & 0xF0;
  if(type===0x90){ if(d2===0) stopNote(d1); else startNote(d1,d2); }
  else if(type===0x80){ stopNote(d1); }
  else if(type===0xB0){
    const cc=d1,val=d2;
    if(cc>=20 && cc<=28){
      const idx=cc-20; const notch=Math.round((val/127)*8); drawbarNotches[idx]=notch;
      const wrap = drawbarsEl.children[idx];
      wrap.querySelector('.cap').textContent = notch;
      wrap.querySelector('.vslider').value = 8 - notch;
      if(started){ activeNotes.forEach(n=> n.oscs[idx].gain.gain.setTargetAtTime(notch/8, ctx.currentTime, 0.01)); }
    } else if(cc===11){
      const v=val/127; document.getElementById('expr').value=v;
      if(started){ activeNotes.forEach(n=> n.gate.gain.setTargetAtTime(v, ctx.currentTime, 0.03)); }
    } else if(cc===64){
      if(started) setLeslie(val>=64?'tremolo':'chorale');
    } else if(cc===1){
      const modes=['off','v1','v2','v3','c1','c2','c3'];
      const ix=Math.floor((val/127)*(modes.length-1)+0.0001);
      const mode=modes[ix]; document.getElementById('vibMode').value=mode;
      if(started) setVibratoMode(mode);
    }
  } else if(type===0xC0){
    if(d1===0){ drawbarNotches=[8,8,8,0,0,0,0,0,0]; buildDrawbars(); }
    else if(d1===1){ drawbarNotches=[8,8,8,8,0,0,0,0,0]; buildDrawbars(); }
    else if(d1===2){ drawbarNotches=[8,8,8,0,0,0,0,0,8]; buildDrawbars(); }
  }
}
async function setupMIDI(){
  if(!('requestMIDIAccess' in navigator)){ log('WebMIDI not supported (use Chrome/Edge over HTTPS).'); return; }
  try{ midi=await navigator.requestMIDIAccess({sysex:false}); }catch(e){ log('MIDI access denied by browser.'); return; }
  function refresh(){
    midiInSel.innerHTML='';
    for(const input of midi.inputs.values()){
      const opt=document.createElement('option'); opt.value=input.id; opt.textContent=input.name; midiInSel.appendChild(opt);
    }
    if(!midi.inputs.size){
      const opt=document.createElement('option'); opt.textContent='No MIDI inputs'; opt.value=''; midiInSel.appendChild(opt);
    }
  }
  refresh(); midi.onstatechange=refresh;
  midiInSel.addEventListener('change', ()=>{
    if(currentInput) currentInput.onmidimessage=null;
    const id=midiInSel.value; currentInput=[...midi.inputs.values()].find(i=>i.id===id);
    if(currentInput){ currentInput.onmidimessage=handleMIDIMessage; log('MIDI input:', currentInput.name); }
  });
  if(midi.inputs.size){
    const first=midi.inputs.values().next().value; midiInSel.value=first.id;
    currentInput=first; currentInput.onmidimessage=handleMIDIMessage; log('MIDI input:', currentInput.name);
  }
}
setupMIDI();

/* ===== On-screen keyboard (C3..C5) with SUSTAIN ===== */
(function(){
  const piano=document.getElementById('piano'); if(!piano) return;
  const WHITE_W=32, BLACK_W=20, BLACK_H=112; const START=48, END=72;
  const isBlack=n=>[1,3,6,8,10].includes(n%12); const isWhite=n=>!isBlack(n);
  const whiteX=new Map(); let whites=0;

  // Build white keys
  for(let n=START;n<=END;n++){
    if(isWhite(n)){ const x=whites*WHITE_W; whiteX.set(n,x);
      const el=document.createElement('div'); el.className='key white'; el.dataset.note=String(n); piano.appendChild(el); whites++;
    }
  }
  piano.style.width=(whites*WHITE_W)+'px';

  // Place black keys
  const leftWhiteForBlack=(n)=>{ const pc=n%12; const leftPc={1:0,3:2,6:5,8:7,10:9}[pc]; if(leftPc===undefined) return null;
    let m=n-1; while(m>=START && (m%12)!==leftPc) m--; return whiteX.has(m)?m:null; };
  for(let n=START;n<=END;n++){
    if(isBlack(n)){ const lw=leftWhiteForBlack(n); if(!lw) continue; const baseX=whiteX.get(lw);
      const left=baseX + WHITE_W - (BLACK_W/2);
      const el=document.createElement('div'); el.className='key black'; el.dataset.note=String(n);
      el.style.left=left+'px'; el.style.height=BLACK_H+'px'; piano.appendChild(el);
    }
  }

  // Sustain state (on-screen only)
  let sustainOn = false;
  const onscreenDown = new Set();   // notes currently held by mouse/touch
  const sustained = new Set();      // notes released while sustain is ON

  const sustainBtn = document.getElementById('sustainBtn');
  sustainBtn.addEventListener('click', ()=>{
    sustainOn = !sustainOn;
    sustainBtn.setAttribute('aria-pressed', String(sustainOn));
    sustainBtn.textContent = 'Sustain: ' + (sustainOn ? 'ON' : 'OFF');
    if(!sustainOn){
      // release all sustained notes that aren't physically held
      for(const n of Array.from(sustained)){
        if(!onscreenDown.has(n)) { stopNote(n); sustained.delete(n); }
      }
    }
  });

  const press=async (el)=>{
    if(!el) return;
    const note=parseInt(el.dataset.note,10);
    el.classList.add('active');
    onscreenDown.add(note);
    sustained.delete(note); // if it was in sustain bucket, it is now physically held again
    try{ if(typeof setupAudio==='function' && !started) setupAudio(); if(ctx && ctx.state==='suspended') await ctx.resume(); }catch(_){}
    if(typeof startNote==='function') startNote(note,110);
  };
  const release=(el)=>{
    if(!el) return;
    const note=parseInt(el.dataset.note,10);
    el.classList.remove('active');
    onscreenDown.delete(note);
    if(sustainOn){
      sustained.add(note); // keep ringing until sustain is toggled off
    }else{
      if(typeof stopNote==='function') stopNote(note);
      sustained.delete(note);
    }
  };

  let mouseDown=false;
  piano.addEventListener('mousedown',(e)=>{ const k=e.target.closest('.key'); mouseDown=true; if(k) press(k); });
  window.addEventListener('mouseup',()=>{ mouseDown=false; piano.querySelectorAll('.key.active').forEach(release); });
  piano.addEventListener('mouseover',(e)=>{ if(!mouseDown) return; const k=e.target.closest('.key'); if(k && !k.classList.contains('active')) press(k); });
  piano.addEventListener('mouseout',(e)=>{ const k=e.target.closest('.key'); if(mouseDown && k) release(k); });

  piano.addEventListener('touchstart',(e)=>{
    e.preventDefault();
    for(const t of e.changedTouches){
      const el=document.elementFromPoint(t.clientX,t.clientY)?.closest('.key'); if(el) press(el);
    }
  },{passive:false});
  piano.addEventListener('touchmove',(e)=>{
    e.preventDefault();
    piano.querySelectorAll('.key.active').forEach(release); // end prior touches
    for(const t of e.changedTouches){
      const el=document.elementFromPoint(t.clientX,t.clientY)?.closest('.key'); if(el) press(el);
    }
  },{passive:false});
  piano.addEventListener('touchend',(e)=>{
    e.preventDefault();
    piano.querySelectorAll('.key.active').forEach(release);
  },{passive:false});
})();
</script>
</body>
</html>

